Test/Unit/Embedding.lean:32:22: warning: unused variable `h`

Note: This linter can be disabled with `set_option linter.unusedVariables false`
Test/Unit/Embedding.lean:32:35: warning: unused variable `h2`

Note: This linter can be disabled with `set_option linter.unusedVariables false`
Try this:
  [apply] smt [h2, h4, h5]
Test/Unit/Embedding.lean:190:39: error: unsolved goals
⊢ (¬∀ (x : ℝ), (∃ a b, x = ↑a / ↑b) → ∀ (x_1 : ℝ), (∃ a b, x_1 = ↑a / ↑b) → x * x_1 = x_1 * x) →
    ∀ (x : ℝ) (a b : ℤ), ↑a / ↑b = a / ↑b

⊢ (¬∀ (x : ℝ), (∃ a b, x = ↑a / ↑b) → ∀ (x_1 : ℝ), (∃ a b, x_1 = ↑a / ↑b) → x * x_1 = x_1 * x) →
    ∀ (x : ℝ) (a b : ℤ), a / ↑b = a / b

⊢ (¬∀ (x : ℝ), (∃ a b, x = ↑a / ↑b) → ∀ (x_1 : ℝ), (∃ a b, x_1 = ↑a / ↑b) → x * x_1 = x_1 * x) →
    ∀ (x x_1 : ℝ) (a b : ℤ), ↑a / ↑b = a / ↑b

⊢ (¬∀ (x : ℝ), (∃ a b, x = ↑a / ↑b) → ∀ (x_1 : ℝ), (∃ a b, x_1 = ↑a / ↑b) → x * x_1 = x_1 * x) →
    ∀ (x x_1 : ℝ) (a b : ℤ), a / ↑b = a / b
Test/Unit/Embedding.lean:190:0: error: (kernel) application type mismatch
  HDiv.hDiv a
argument has type
  ℤ
but function has type
  ℝ → ℝ → ℝ
Test/Unit/Embedding.lean:302:50: error: unsolved goals
⊢ (¬∀ (x : ℝ), (∃ a b, x = ↑a / ↑b) → ∀ (x_1 : ℝ), (∃ a b, x_1 = ↑a / ↑b) → 0 ≤ x - x_1 ∨ x - x_1 < 0) →
    ∀ (x : ℝ) (a b : ℤ), ↑a / ↑b = a / ↑b

⊢ (¬∀ (x : ℝ), (∃ a b, x = ↑a / ↑b) → ∀ (x_1 : ℝ), (∃ a b, x_1 = ↑a / ↑b) → 0 ≤ x - x_1 ∨ x - x_1 < 0) →
    ∀ (x : ℝ) (a b : ℤ), a / ↑b = a / b

⊢ (¬∀ (x : ℝ), (∃ a b, x = ↑a / ↑b) → ∀ (x_1 : ℝ), (∃ a b, x_1 = ↑a / ↑b) → 0 ≤ x - x_1 ∨ x - x_1 < 0) →
    ∀ (x x_1 : ℝ) (a b : ℤ), ↑a / ↑b = a / ↑b

⊢ (¬∀ (x : ℝ), (∃ a b, x = ↑a / ↑b) → ∀ (x_1 : ℝ), (∃ a b, x_1 = ↑a / ↑b) → 0 ≤ x - x_1 ∨ x - x_1 < 0) →
    ∀ (x x_1 : ℝ) (a b : ℤ), a / ↑b = a / b
Test/Unit/Embedding.lean:302:0: error: (kernel) application type mismatch
  HDiv.hDiv a
argument has type
  ℤ
but function has type
  ℝ → ℝ → ℝ
Test/Unit/Embedding.lean:309:2: error: [poly_norm] expected a rational number, got x.7407
Test/Unit/Embedding.lean:315:2: error: Application type mismatch: The argument
  x.7376
has type
  ℤ
but is expected to have type
  ℝ
in the application
  HDiv.hDiv x.7376
Map: []
Map: []
goal: ∃ x, (∃ a b, x = ↑a / ↑b) ∧ ((∃ a b, x = ↑a / ↑b) → x = 0)

query:
(set-logic ALL)
(assert (not (exists ((x Real)) (and (exists ((a Int)) (exists ((b Int)) (= x (/ (to_real a) (to_real b))))) (=> (exists ((a Int)) (exists ((b Int)) (= x (/ (to_real a) (to_real b))))) (= x 0.0))))))
(check-sat)
Test/Unit/Embedding.lean:317:30: error: unsolved goals
⊢ ∃ x, (∃ a b, x = ↑a / ↑b) ∧ ((∃ a b, x = ↑a / ↑b) → x = 0)
goal: ∃ x, (∃ a b, x = ↑a / ↑b) ∧ ((∃ a b, x = ↑a / ↑b) → x ≤ f x)

query:
(set-logic ALL)
(declare-fun f (Real) Real)
(assert (forall ((x Real)) (=> (exists ((a Int)) (exists ((b Int)) (= x (/ (to_real a) (to_real b))))) (exists ((a Int)) (exists ((b Int)) (= (f x) (/ (to_real a) (to_real b))))))))
(assert (not (exists ((x Real)) (and (exists ((a Int)) (exists ((b Int)) (= x (/ (to_real a) (to_real b))))) (=> (exists ((a Int)) (exists ((b Int)) (= x (/ (to_real a) (to_real b))))) (<= x (f x)))))))
(check-sat)
Test/Unit/Embedding.lean:333:42: error: unsolved goals
f : ℚ → ℚ
⊢ ∃ n, f n ≥ n
goal: ∃ x x_1, (∃ a b, x_1 = ↑a / ↑b) ∧ ((∃ a b, x_1 = ↑a / ↑b) → x_1 ≤ f x x_1)

query:
(set-logic ALL)
(declare-fun f (Int Real) Real)
(assert (forall ((|a₁| Int)) (forall ((|a₂| Real)) (exists ((a Int)) (exists ((b Int)) (= (f |a₁| |a₂|) (/ (to_real a) (to_real b))))))))
(assert (not (exists ((x Int)) (exists ((x_1 Real)) (and (exists ((a Int)) (exists ((b Int)) (= x_1 (/ (to_real a) (to_real b))))) (=> (exists ((a Int)) (exists ((b Int)) (= x_1 (/ (to_real a) (to_real b))))) (<= x_1 (f x x_1))))))))
(check-sat)
Test/Unit/Embedding.lean:336:52: error: unsolved goals
f : ℤ → ℚ → ℚ
⊢ ∃ x n, f x n ≥ n
Test/Unit/Embedding.lean:343:2: error: Application type mismatch: The argument
  a
has type
  ℤ
but is expected to have type
  ℝ
in the application
  HDiv.hDiv a
Test/Unit/Embedding.lean:345:52: error: unsolved goals
f : ℝ → ℝ
a✝ : ∀ (x : ℝ), (∃ a b, x = ↑a / ↑b) → ∃ a b, f x = ↑a / ↑b
⊢ (∀ (x : ℝ), (∃ a b, x = ↑a / ↑b) → ∃ a b, f x = ↑a / ↑b) →
    (¬∀ (x : ℝ), (∃ a b, x = ↑a / ↑b) → 0 ≤ f x ∨ f x < 0) → ∀ (x : ℝ) (a b : ℤ), ↑a / ↑b = a / ↑b

f : ℝ → ℝ
a✝ : ∀ (x : ℝ), (∃ a b, x = ↑a / ↑b) → ∃ a b, f x = ↑a / ↑b
⊢ (∀ (x : ℝ), (∃ a b, x = ↑a / ↑b) → ∃ a b, f x = ↑a / ↑b) →
    (¬∀ (x : ℝ), (∃ a b, x = ↑a / ↑b) → 0 ≤ f x ∨ f x < 0) → ∀ (x : ℝ) (a b : ℤ), a / ↑b = a / b
Test/Unit/Embedding.lean:345:0: error: (kernel) application type mismatch
  HDiv.hDiv a
argument has type
  ℤ
but function has type
  ℝ → ℝ → ℝ
Test/Unit/Embedding.lean:349:2: error: Application type mismatch: The argument
  a
has type
  ℤ
but is expected to have type
  ℝ
in the application
  HDiv.hDiv a
goal: ∃ x, (∃ a b, x = ↑a / ↑b) ∧ ((∃ a b, x = ↑a / ↑b) → 0 ≤ x ∧ f x)

query:
(set-logic ALL)
(declare-const x Real)
(assert (exists ((a Int)) (exists ((b Int)) (= x (/ (to_real a) (to_real b))))))
(declare-fun f (Real) Bool)
(assert (f x))
(assert (not (exists ((x Real)) (and (exists ((a Int)) (exists ((b Int)) (= x (/ (to_real a) (to_real b))))) (=> (exists ((a Int)) (exists ((b Int)) (= x (/ (to_real a) (to_real b))))) (and (<= 0.0 x) (f x)))))))
(check-sat)
Test/Unit/Embedding.lean:351:67: error: unsolved goals
p : ℚ → Prop
w : ℚ
h : p w
⊢ ∃ x ≥ 0, p x
Test/Unit/Embedding.lean:355:2: error: [poly_norm] expected a rational number, got x.7380
Test/Unit/Embedding.lean:357:83: error: unsolved goals
⊢ ∀ (f : ℝ → ℤ → ℝ),
    (∀ (x : ℝ), (∃ a b, x = ↑a / ↑b) → ∀ (a₂ : ℤ), ∃ a b, f x a₂ = ↑a / ↑b) →
      ∀ (x : ℝ), (∃ a b, x = ↑a / ↑b) → ∀ {y : ℤ} {h : ↑y = x} {h' : f x y ≠ ↑(f ↑y ⌊x⌋).toRat}, False
